<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Polarization</title>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body {
            background: #0a0a0f;
            color: #fff;
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            min-height: 100vh;
            display: flex;
            align-items: center;
            justify-content: center;
            padding: 20px;
        }

        .back-link {
            position: fixed;
            top: 20px;
            left: 20px;
            color: #666;
            text-decoration: none;
            font-size: 13px;
            z-index: 100;
        }
        .back-link:hover { color: #fff; }

        .container {
            width: 1200px;
            max-width: 100%;
        }

        svg {
            display: block;
            background: #111;
            border-radius: 8px;
        }
    </style>
</head>
<body>
    <a href="../index.html" class="back-link">‚Üê Back</a>

    <div class="container">
        <svg id="viz" width="1200" height="600" viewBox="0 0 1200 600"></svg>
    </div>

    <script>
        const svg = document.getElementById('viz');
        const width = 1200;
        const height = 600;

        // Large blue circles on the left
        const leftCircles = 8;
        const largeRadius = 30;
        const leftX = 60;

        for (let i = 0; i < leftCircles; i++) {
            const y = (height / (leftCircles + 1)) * (i + 1);
            const circle = document.createElementNS('http://www.w3.org/2000/svg', 'circle');
            circle.setAttribute('cx', leftX);
            circle.setAttribute('cy', y);
            circle.setAttribute('r', largeRadius);
            circle.setAttribute('fill', '#3B82F6');
            svg.appendChild(circle);
        }

        // Large red circles on the right
        const rightCircles = 8;
        const rightX = width - 60;

        for (let i = 0; i < rightCircles; i++) {
            const y = (height / (rightCircles + 1)) * (i + 1);
            const circle = document.createElementNS('http://www.w3.org/2000/svg', 'circle');
            circle.setAttribute('cx', rightX);
            circle.setAttribute('cy', y);
            circle.setAttribute('r', largeRadius);
            circle.setAttribute('fill', '#EF4444');
            svg.appendChild(circle);
        }

        // Greyscale filter for emojis
        const defs = document.createElementNS('http://www.w3.org/2000/svg', 'defs');
        defs.innerHTML = `
            <filter id="grayscale">
                <feColorMatrix type="saturate" values="0"/>
            </filter>
        `;
        svg.appendChild(defs);

        // Emoji people filling the middle
        const emojiSize = 14;
        const middleStartX = 120;
        const middleEndX = width - 120;
        const padding = emojiSize * 1.4;
        const emoji = 'üò¨';

        // Create a grid of emojis
        for (let x = middleStartX; x <= middleEndX; x += padding) {
            for (let y = emojiSize + 20; y <= height - emojiSize - 20; y += padding) {
                // Add slight randomness to position
                const jitterX = (Math.random() - 0.5) * 6;
                const jitterY = (Math.random() - 0.5) * 6;

                const text = document.createElementNS('http://www.w3.org/2000/svg', 'text');
                text.setAttribute('x', x + jitterX);
                text.setAttribute('y', y + jitterY);
                text.setAttribute('font-size', emojiSize);
                text.setAttribute('text-anchor', 'middle');
                text.setAttribute('dominant-baseline', 'middle');
                text.setAttribute('filter', 'url(#grayscale)');
                text.setAttribute('opacity', '0.6');
                text.textContent = emoji;
                svg.appendChild(text);
            }
        }

        // Rockets flying between edges
        function createRocket(fromLeft) {
            const rocket = document.createElementNS('http://www.w3.org/2000/svg', 'g');

            const startX = fromLeft ? 80 : width - 80;
            const endX = fromLeft ? width - 80 : 80;
            const y = 80 + Math.random() * (height - 160);
            const color = fromLeft ? '#3B82F6' : '#EF4444';

            // Rocket body
            const body = document.createElementNS('http://www.w3.org/2000/svg', 'ellipse');
            body.setAttribute('rx', '30');
            body.setAttribute('ry', '12');
            body.setAttribute('fill', color);
            rocket.appendChild(body);

            // Rocket tip
            const tip = document.createElementNS('http://www.w3.org/2000/svg', 'polygon');
            const tipDir = fromLeft ? 1 : -1;
            tip.setAttribute('points', `${30 * tipDir},0 ${50 * tipDir},-8 ${50 * tipDir},8`);
            tip.setAttribute('fill', color);
            rocket.appendChild(tip);

            // Flame trail
            const flame = document.createElementNS('http://www.w3.org/2000/svg', 'polygon');
            const flameDir = fromLeft ? -1 : 1;
            flame.setAttribute('points', `${30 * flameDir},0 ${60 * flameDir},-6 ${50 * flameDir},0 ${60 * flameDir},6`);
            flame.setAttribute('fill', '#F59E0B');
            flame.setAttribute('opacity', '0.8');
            rocket.appendChild(flame);

            rocket.setAttribute('transform', `translate(${startX}, ${y})`);
            svg.appendChild(rocket);

            // Animate
            const duration = 2000 + Math.random() * 1500;
            const startTime = performance.now();

            function animate(time) {
                const elapsed = time - startTime;
                const progress = Math.min(elapsed / duration, 1);

                // Ease out
                const eased = 1 - Math.pow(1 - progress, 2);
                const currentX = startX + (endX - startX) * eased;

                rocket.setAttribute('transform', `translate(${currentX}, ${y})`);

                if (progress < 1) {
                    requestAnimationFrame(animate);
                } else {
                    svg.removeChild(rocket);
                    createExplosion(endX, y, color);
                }
            }

            requestAnimationFrame(animate);
        }

        function createExplosion(x, y, color) {
            const numParticles = 12;
            const particles = [];

            for (let i = 0; i < numParticles; i++) {
                const particle = document.createElementNS('http://www.w3.org/2000/svg', 'circle');
                const angle = (i / numParticles) * Math.PI * 2;
                particle.setAttribute('cx', x);
                particle.setAttribute('cy', y);
                particle.setAttribute('r', 6 + Math.random() * 4);
                particle.setAttribute('fill', i % 2 === 0 ? color : '#F59E0B');
                particle.setAttribute('opacity', '1');
                svg.appendChild(particle);
                particles.push({
                    el: particle,
                    angle: angle,
                    speed: 40 + Math.random() * 30
                });
            }

            const startTime = performance.now();
            const duration = 400;

            function animateExplosion(time) {
                const elapsed = time - startTime;
                const progress = Math.min(elapsed / duration, 1);

                particles.forEach(p => {
                    const dist = p.speed * progress;
                    const px = x + Math.cos(p.angle) * dist;
                    const py = y + Math.sin(p.angle) * dist;
                    p.el.setAttribute('cx', px);
                    p.el.setAttribute('cy', py);
                    p.el.setAttribute('opacity', 1 - progress);
                    p.el.setAttribute('r', (6 + Math.random() * 4) * (1 - progress * 0.5));
                });

                if (progress < 1) {
                    requestAnimationFrame(animateExplosion);
                } else {
                    particles.forEach(p => svg.removeChild(p.el));
                }
            }

            requestAnimationFrame(animateExplosion);
        }

        // Launch rockets periodically
        function launchRocket() {
            const fromLeft = Math.random() > 0.5;
            createRocket(fromLeft);
            setTimeout(launchRocket, 800 + Math.random() * 1200);
        }

        // Start launching
        setTimeout(launchRocket, 500);
    </script>
</body>
</html>
